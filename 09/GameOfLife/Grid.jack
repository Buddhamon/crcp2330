// Will Lacey
// May 8th 2018
// Game of Life in Jack - Grid

class Grid 
{
   field Array grid; // 32 by 64, squares with side of 8 pixels?
   field int grid_rows;
   field int grid_cols;
   field int grid_length;

   field int totalAliveCells;

   constructor Grid new() 
   {  
      var int index;
      let index = 0;

      let grid_rows = 32;
      let grid_cols = 64;
      let grid_length = 32 * 64;
      let totalAliveCells = 0;

      let grid = Array.new(grid_length); // constructs the array for grid

      while(index < grid_length) // initializing grid
      {
         let grid[index] = Cell.new_i(index);
         let index = index + 1;
      }

      return this;   // a constructor is expected to return a reference to the new object
   }

   method void tick()
   {
      var int row;
      var int col;
      var int neighborCount;
      var Cell temp_grid_cell;
      var Cell grid_cell;
      var int index;
      var int alive;
      var Grid temp_grid;

      let index = 0;
      while(index < grid_length) // initializing temp_grid
      {
         let temp_grid_cell = grid[index];
         let temp_grid[index] = Cell.new_i(temp_grid_cell);
         let index = index + 1;
      }

      let totalAliveCells = 0;
      let row = 0;
      let col = 0;

      //Check all cells
      while(row < grid_rows)
      {
         let col = 0;
         while(col < grid_cols)
         { 
            let index = getCellIndex(row, col);
            let temp_grid_cell = temp_grid[index];
            let neighborCount = cellNeighborCount(row, col);
            if(neighborCount < 2 & temp_grid_cell.isAlive()) // rule 1 - under population
            {
               do temp_grid_cell.dies();
            }
            if(1 < neighborCount & neighborCount < 4 & temp_grid_cell.isAlive()) // rule 2 - starvation
            {
               // do nothing
            }
            if(neighborCount > 3 & temp_grid_cell.isAlive()) // rule 3 - over population
            {
               do temp_grid_cell.dies();
            }
            if(neighborCount = 3 & ~temp_grid_cell.isAlive()) // rule 4 - repopulation
            {
               do temp_grid_cell.spawns();
               let totalAliveCells = totalAliveCells + 1;
            }
            else
            {
               do Output.printString("1 tick - Rule Error ");
               do Sys.error(0);
            }
            let col = col + 1;
         }
         let row = row + 1;
      }

      while(index < grid_length) // setting grid equal to temp_grid
      {
         let temp_grid_cell = temp_grid[index];
         let grid_cell = grid[index];
         let alive = temp_grid_cell.isAlive();
         if(alive)
         {
            do grid_cell.spawns();
         }
         else
         {
            do grid_cell.dies();
         }
         let index = index + 1;
      }

      do temp_grid.dispose();
      return;
   }

   method int cellNeighborCount(int row, int col)
   {
      var int neighborCount;
      var Cell neighbor_cell;
      var int index;
      var boolean alive;

      var boolean up;
      var boolean right;
      var boolean down;
      var boolean left;
      let up = false;
      let right = false;
      let down = false;
      let left = false;

      // Checks to see which neighbors the cell has
      if(row > 0) { let up = true;}
      if(col < grid_cols) { let right = true;}
      if(row < 0) { let down = true;}
      if(col > 0) { let left = true;}

      let neighborCount = 0;

      if(up)
      {
         let index = getCellIndex(row-1, col);
         let neighbor_cell = grid[index];
         let alive = neighbor_cell.isAlive();
         if(alive)
         {
            let neighborCount = neighborCount + 1;
         }
      }
      if(up & right)
      {
         let index = getCellIndex(row-1, col+1);
         let neighbor_cell = grid[index];
         let alive = neighbor_cell.isAlive();
         if(alive)
         {
            let neighborCount = neighborCount + 1;
         }
      }
      if(right)
      {
         let index = getCellIndex(row, col+1);
         let neighbor_cell = grid[index];
         let alive = neighbor_cell.isAlive();
         if(alive)
         {
            let neighborCount = neighborCount + 1;
         }
      }
      if(down & right)
      {
         let index = getCellIndex(row+1, col+1);
         let neighbor_cell = grid[index];
         let alive = neighbor_cell.isAlive();
         if(alive)
         {
            let neighborCount = neighborCount + 1;
         }
      }
      if(down)
      {
         let index = getCellIndex(row+1, col);
         let neighbor_cell = grid[index];
         let alive = neighbor_cell.isAlive();
         if(alive)
         {
            let neighborCount = neighborCount + 1;
         }
      }
      if(down & left)
      {
         let index = getCellIndex(row+1, col-1);
         let neighbor_cell = grid[index];
         let alive = neighbor_cell.isAlive();
         if(alive)
         {
            let neighborCount = neighborCount + 1;
         }
      }
      if(left)
      {
         let index = getCellIndex(row, col-1);
         let neighbor_cell = grid[index];
         let alive = neighbor_cell.isAlive();
         if(alive)
         {
            let neighborCount = neighborCount + 1;
         }
      }
      if(up & left)
      {
         let index = getCellIndex(row-1, col-1);
         let neighbor_cell = grid[index];
         let alive = neighbor_cell.isAlive();
         if(alive)
         {
            let neighborCount = neighborCount + 1;
         }
      }
      return neighborCount;
   }

   method int getCellIndex(int row, int col)
   {
      var int index;
      if(row > (grid_rows - 1))
      {
         do Output.printString("1 getCell - Out of Bounds ");
         do Sys.error(0);
      }
      if(row < 0)
      {
         do Output.printString("2 getCell - Out of Bounds ");
         do Sys.error(0);
      }
      if(col > (grid_cols - 1))
      {
         do Output.printString("3 getCell - Out of Bounds ");
         do Sys.error(0);
      }
      if(col < 0)
      {
         do Output.printString("4 getCell - Out of Bounds ");
         do Sys.error(0);
      }
      let index = col;
      let index = index + (row*64);
      return index;
   }

   method void draw() 
   {

      return;
   }

   //Getters
   method int getTotalAliveCells() { return totalAliveCells; }

   method void dispose()
   {
      var int index;
      var Cell cell;

      let index = 0;
      while(index < grid_length) // initializing grid
      {
         let cell = grid[index];
         do cell.dispose();
         let index = index + 1;
      }
      do grid.dispose();
      do Memory.deAlloc(this);  // uses an OS routine to recycle the memory held by the object
      return;
   }
}
